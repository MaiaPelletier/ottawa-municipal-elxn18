---
title: "Voter turnout for close election races"
author: "Maia Pelletier"
date: "30/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(janitor)
library(readxl)
library(tidyr)
library(ggthemes)
library(kableExtra)
```

# Does voter turnout increase for close election races?  

I'm in a class this semester called Data Science Lab and one of our weekly assignments is to investigate the claim that closer races lead to higher turnouts. Specifically, we're looking at data from the city of Ottawa municipal election in 2018.  

This assignment is a little more vague than the other ones we've been given up until now, so I'm excited to dive in and tackle this problem.  

### Approach  

After sitting down for a few minutes, I think the most straight-forward way of attacking this is:
  1. Find the margin between the winner and runner-up in each ward (Fraction of votes for the winner - fraction of votes for the runner-up)
  2. Find relative voter turn-out (Total votes cast in a ward vs registered voters in a ward)  
  3. Preform a linear regression these 2 measures and evaluate if this model finds a significant relationship  
Seems easy enough! Famous last words, but let's dive in anyway.  

First things first, I wanted to visualize how close the race in each ward actually was. This is easier said than done. There are 23 wards in the city of Ottawa and each ward's data is on a seperate sheet of an excel workbook. Thank god that `{readxl}`exists.  

This is what the data looks like from Ward 1, without any cleaning, etc. (to give an idea of what we're working with)  

```{r}
file <- 'statementofvotescastoctober242018.xls'

read_excel(file, sheet = 3, skip = 2) %>%
  head(10) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

This is... not so nice. So I wrote a cleaner function that also extracts the ward winner(s) from this data and finds the number of votes they received, as well as the fraction of the total votes.  

```{r, warning=FALSE, message=FALSE}

# Function to clean and gather ward winner(s)
get_winners <- function(ward, num_of_winners = 1){
  
  clean_ward <- 
    ward %>%
    clean_names() %>%
    select(-starts_with('x')) %>%
    na.omit() %>%
    select(-precinct_7) %>%
    rename(precinct = precinct_1) %>%
    filter(!str_detect(precinct, 'Total'))
  
  ward_long <- 
    clean_ward %>%
    gather('candidate', 'votes', 5:(ncol(clean_ward)-1)) %>%
    #pivot_longer(5:(ncol(clean_ward)-1), names_to = 'candidate', values_to = 'votes') %>%
    mutate(candidate = str_to_title(str_replace_all(candidate, '_', ' '))) %>% 
    separate(precinct, c('precinct_id', 'precinct_name'), sep = ' - ', extra = 'merge') %>%
    filter(!str_detect(precinct_id, 'Adv')) 
  
  ward_winner <- 
    ward_long %>%
    group_by(candidate) %>%
    summarise(total_candidate_votes = sum(votes)) %>%
    mutate(total_ward_votes = sum(total_candidate_votes),
           frac_candidate_votes = total_candidate_votes/total_ward_votes) %>%
    top_n(num_of_winners, total_candidate_votes)
  
  return(ward_winner)
}

num_of_wards <- 23

# Iterate over number of wards to build df of ward winners
ward_winners_df <- tibble()
for (i in 1:num_of_wards) {
  add_ward <- get_winners(read_excel(file, sheet = i + 2, skip = 2), num_of_winners = 2)
  ward_winners_df <- bind_rows(ward_winners_df, mutate(add_ward, ward = i))
}

ward_winners_df %>%
  head(10) %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

After iterating to extract this information from each ward, we are left with a table that has a list of all the winners and runner-ups from each ward. This is easy to work with and visualize. I decided to go with a dumbbell dot plot, to be able to easily compare close vs not-close races.  


``` {r, echo = FALSE}

# Widen ward winner df and label winners and runner-ups
ward_winners_wide <- 
  ward_winners_df %>%
    group_by(ward) %>%
    mutate(maxvotes = max(total_candidate_votes)) %>%
    mutate(rank = ifelse(total_candidate_votes == maxvotes, 'winner', 'runner-up')) %>%
    select(-maxvotes, -candidate, -frac_candidate_votes, -total_ward_votes) %>%
    spread(rank, total_candidate_votes)
    #pivot_wider(names_from = rank, values_from = total_candidate_votes)

# Plot ward winner and runner-up
ggplot(ward_winners_wide) +
  geom_segment(aes(x = factor(ward), xend = ward, y = `runner-up`, yend = winner), size = 1, color = 'grey55') +
  geom_point(aes(x = ward, y = `runner-up`, color = 'runner-up'), size = 5, alpha = 0.7) +
  geom_point(aes(x = ward, y = winner, color = 'winner'), size = 5, alpha = 0.7) +
  coord_flip() +
  labs(x = NULL, y = 'Votes', title = 'Vote totals for winner & runner-up in each ward', 
       subtitle = '2018 Ottawa municipal election') +
  scale_x_discrete(labels = paste('Ward', 1:23)) +
  scale_color_canva(palette = 'Summer sunflower', name = NULL) +
  theme_hc() +
  theme(plot.title = element_text(size = 22, face = 'italic', color = 'grey30'),
        plot.subtitle = element_text(size = 11, color = 'grey30'),
        axis.text.x = element_text(size = 8),
        axis.title.x = element_text(size = 10))
```

This looks great! We can see that the races we're really close in wards 1, 17, 18, and 21. I'll have to take a look at these wards in particular when we get our final results. The next thing I need to do is actually calculate the margin between the runner-ups and winners.  

```{r calc margin}
margin_df <-
  ward_winners_df %>%
  group_by(ward) %>%
  mutate(minvotes = min(frac_candidate_votes)) %>%
  mutate(margin = frac_candidate_votes-minvotes) %>%
  top_n(1, total_candidate_votes)

margin_df %>%
  arrange(margin) %>%
  head(10) %>%
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

Now we have our first step completed: a nice table containing the margin between the winners and runner-ups. The next thing we have to do is calculate the voter turnout in all the wards. The excel workbook contains a sheet that has a summary page, containing the numbers for registered voters and the number of votes cast at each polling station. This is what I'm going to use to find the approximate voter turnout. This isn't a perfect estimate for voter turnout however, since Canada has day-of registration. Voters who registered on the day of the election would not be counted in the `registered voters` column.  

```{r, message=FALSE}
elxn_summary <- 
  read_excel(file, sheet = 1, skip = 2) %>%
  clean_names() %>% # Clean col names
  select(-starts_with('x')) %>% # Remove empty cols
  filter(!is.na(registered_voters), !str_detect(precinct, 'City / Ville - Total'))  %>%  # Remove totals rows
  separate(precinct, c('precinct_id', 'precinct_name'), ' - ', extra = 'merge') %>% # Separate names from polling station IDs
  filter(!str_detect(precinct_id, 'Spc Adv')) %>% # Remove specialty advance polling
  mutate(precinct_id = str_remove(precinct_id, 'Adv 1')) %>% # Clean polling station IDs
  separate(precinct_id, c('ward', 'polling_station_no'), sep = '-') %>% # Seperate the ward number from the polling station ID
  mutate(ward = as.numeric(ward)) %>% # Coerce ward ID from chr to dbl
  group_by(ward) %>% 
  summarise(total_registered_voters = sum(registered_voters), # Find total registered voters in all wards
            total_cards_cast = sum(cards_cast)) %>% # Find total votes cast in all wards
  mutate(frac_votes = total_cards_cast/total_registered_voters) # Calculate turn-out

elxn_summary %>%
  arrange(desc(frac_votes)) %>%
  head(10) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

Here we can see the wards with the highest voter turn-out. We see 17 and 22 are in the top 10, which begins to support my initial hypothesis. (Recall that 17 and 22 had close election races.)  

Let's join the data and take a look at the relationship between the turn-out and margin between winners and runner-ups.  

```{r, echo = FALSE}
final_df <-
  margin_df %>% 
  right_join(elxn_summary, by = 'ward')

final_df %>% 
  ggplot(aes(frac_votes, margin)) +
  geom_point(aes(color = margin), size = 5, alpha = 0.8) +
  geom_smooth(formula = y ~ x, method = 'lm', alpha = 0.1, color = 'lightblue') +
  geom_text(aes(label = paste('Ward', ward)), nudge_y = 0.040, nudge_x = 0.0025, size = 3, check_overlap = TRUE, color = 'grey55') +
  labs(x = 'Fraction of registered voters who cast votes', y = 'Margin between candidates') +
  ggtitle('Do closer races lead to higher voter turnouts?', subtitle = 'Analysis of Ottawa 2018 municipal election') +
  theme_minimal() +
  viridis::scale_color_viridis(name = 'Margin') +
  theme(axis.title = element_text(color = 'grey40', face = 'italic', size = 10),
        axis.text = element_text(color = 'grey40', size = 8),
        plot.title = element_text(color = 'grey20', face = 'italic', size = 16, hjust = 0.5),
        plot.subtitle = element_text(color = 'grey30', size = 10))
```

This is good! It supports our initial hypothesis: As the margin gets smaller, the voter-turnout increases (approximately). Note, the method used for `geom_smooth()` is `'lm'`. So let's perform a linear regression to investigate whether we conclude if this relationship is significant or not.  

```{r}
mod <- lm(margin ~ frac_votes, data = final_df)
summary(mod)
```

yes!

# References  

https://en.m.wikipedia.org/wiki/List_of_close_election_results
